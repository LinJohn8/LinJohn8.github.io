<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>林翰 - 独立游戏开发者 & 人工智能开发者</title>

    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="style.css"> 

</head>
<body>

    <div id="loader">
        <div class="loader-content">
            <div class="spinner"></div>
            <h2 style="color: white; font-weight: 500;">林翰的个人主页</h2>
            <p style="color: rgba(255,255,255,0.8); margin-top: 15px;">INITIALIZING...</p>
        </div>
    </div>

    <div class="split-wrapper">

        <div class="content-panel">

            <header id="header">
                <h1>林翰 / LinJohn</h1>
                <nav>
                    <a href="index.html"><i class="fas fa-home"></i> 主页</a>
                    <a href="about.html"><i class="fas fa-user"></i> 关于我</a>
                    <a href="projects.html"><i class="fas fa-code"></i> 项目经历</a>
                    <a href="support.html"><i class="fas fa-heart"></i> (#^.^#)支持一下(#^.^#)</a>
                </nav>
            </header>

            <main>
                <section id="myself">
                    <h2><i class="fas fa-id-card"></i> 网名 / Terminal ID</h2>
                    <div class="typing-text" id="nickname-typing"></div>
                </section>

                <section id="about">
                    <h2><i class="fas fa-info-circle"></i> 关于我 / About Me</h2>
                    
                    <div class="flip-card">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <p>点击或悬停查看核心标签</p>
                            </div>
                            <div class="flip-card-back">
                                <h3>个人简介</h3>
                                <p>独立游戏开发者 & 人工智能开发者<br>专注于Unreal Engine开发与AI技术融合</p>
                            </div>
                        </div>
                    </div>
                    <a href="about.html" class="btn">查看完整介绍 <i class="fas fa-arrow-right"></i></a>
                </section>

                <section id="projects">
                    <h2><i class="fas fa-laptop-code"></i> 项目经历 / Projects</h2>
                    <p>了解我在 Unreal Engine 和 AI 领域的工作成果。</p>
                    <a href="projects.html" class="btn">查看我的项目 <i class="fas fa-arrow-right"></i></a>
                </section>
                
                <section id="home" class="intro">
                    <h2><i class="fas fa-user-circle"></i> 个人自述 / Personal Statement</h2>
                    <p>大家好，这是一段关于我个人经历的分享。2021年10月，我开始接触并学习Unreal Engine相关技术，当时用的是4.26版本，至今仍是记忆犹新。</p>
                    <p>学习之初，我并没有直接接触编程，而是先从地编入手。那段时间，我花了大量时间在模型制作、UV拆分、光照烘焙、贴图绘制、材质调试以及场景搭建上，甚至还深入研究了粒子特效。蓝图对那时的我而言，还是一片陌生的领域。</p>
                    <p>做了一些简单场景后，我意识到自己不满足于此。我想要的是做出一款真正的游戏，于是我开始学习蓝图，开始制作了一些小项目。虽然现在回头看这些项目，都是简单而略显粗糙的项目Demo，但对当时的我来说，都是可以展示的Demo了。</p>
                    <p>随后，我发现仅靠蓝图远远不够。虽然当时对C++一知半解，在哔哩哔哩上看相关视频时也常常云里雾里，但我没有放弃，开始从C语言入手，逐渐掌握C++，最终进入了Unreal Engine的C++编程领域。</p>
                    <p>期间，我也不断刷算法题、参加编程比赛，虽未取得特别优异的成绩，但我的目标一直不在纯技术的深耕，而是致力于游戏制作。</p>
                    <p>我曾有一次宝贵的实习经历，期间利用UE5结合AI技术，我们参与了由习近平主席致辞的2023年乌镇世界互联网峰会项目。</p>
                    <p>此后我开始接触AI，学习了从大模型对话、图像生成、视频处理、语音合成（TTS）到检索增强生成（RAG）等技术，技能不断丰富。然而，游戏开发的进度却因时间有限而停滞。我曾尝试用一个月时间独自开发游戏，但时间远远不够。</p>
                    <p>我很喜欢"独立游戏开发者"这个称号，也许是因为它带有一种独行侠的意味。但有时我也被称作人工智能领域的开发者，命运真是有趣。</p>
                    <p>现在我越来越觉得自己在向全栈开发者方向靠近，还需要继续努力。我依然渴望制作一款令自己满意的游戏，或许这源于我对细节的严格要求吧。</p>
                </section>
                
                <section id="pictures">
                    <h2><i class="fas fa-images"></i> 一些相关图片 / Media Gallery</h2>
                    <p>点击图片查看大图。</p>
                    <div class="gallery">
                        <img class="zoomable" src="assets/Self/1.jpg" alt="个人照">
                        <img class="zoomable" src="assets/Self/2.jpg" alt="2023乌镇世界互联网峰会">
                        <img class="zoomable" src="assets/Self/3.jpg" alt="第三届济南国际双年展">
                        <img class="zoomable" src="assets/Self/4.jpg" alt="上海油罐艺术中心-未来样本-1">
                        <img class="zoomable" src="assets/Self/5.jpg" alt="未来样本的第一次线下版">
                        <img class="zoomable" src="assets/Self/6.jpg" alt="未来样本人员和项目理念">
                        <img class="zoomable" src="assets/Self/7.jpg" alt="上海油罐艺术中心-未来样本-2">
                        <img class="zoomable" src="assets/Self/8.jpg" alt="第二届SOULSCAPES灵源AIGC艺术设计展">
                        <img class="zoomable" src="assets/Self/9.jpg" alt="m360人机共振">
                        <img class="zoomable" src="assets/Self/10.jpg" alt="毛雯婧对未来样本的项目分享">
                        <img class="zoomable" src="assets/Self/11.jpg" alt="参加第十届全球区块链峰会">
                        <img class="zoomable" src="assets/Self/12.jpg" alt="第三届济南国际双年展合影">
                        <img class="zoomable" src="assets/Self/13.jpg" alt="Unreal合影-1">
                        <img class="zoomable" src="assets/Self/14.jpg" alt="Unreal合影-2">
                        <img class="zoomable" src="assets/Self/15.jpg" alt="Unreal合影-3">
                        <img class="zoomable" src="assets/Self/16.jpg" alt="Unreal合影-4">
                    </div>
                </section>
                
                <section id="contact">
                    <h2><i class="fas fa-envelope"></i> 联系我 / Contact</h2>
                    
                    <div class="contact-form">
                        <div class="form-group">
                            <p>个人比较少看邮箱，所以回复可能比较慢。但如果您有项目合作意向，我会尽快回复。</p>
                            <p style="font-size: 1.1rem; color: var(--neon-cyan);">q244645787@gmail.com</p>
                        </div>
                    </div>
                </section>
            </main>

            <footer>
                <div class="social-icons">
                    <a href="https://github.com/LinJohn8" class="social-icon"><i class="fab fa-github"></i></a>
                </div>
                
                <p>© 2025 林翰 - 个人介绍 | Rendered with Three.js</p>
            </footer>
        </div>
        
        <div class="visual-panel" id="visual-panel">
            <div id="three-background"></div>
            <div id="visual-loader">
                <div class="spinner"></div>
                <p>Loading 3D Assets...</p>
            </div>
        </div>
    </div>

    <div id="lightbox" class="lightbox" style="display: none;">
        <span class="close">&times;</span>
        <img class="lightbox-img" src="" alt="大图">
    </div>
    
    <div class="back-to-top" id="backToTop">
        <i class="fas fa-arrow-up"></i>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12" defer></script>

    <script>
        // --- 通用 JS 逻辑 ---
        
        // 页面加载动画（快速淡出）
        window.addEventListener('load', function() {
            const loader = document.getElementById('loader');
            setTimeout(() => {
                loader.style.opacity = '0';
                loader.style.visibility = 'hidden';
            }, 300); // 300ms 快速淡出
        });
        
        // DOM 内容加载完成后的初始化
        document.addEventListener('DOMContentLoaded', function() {
            // 1. 打字机效果
            new Typed('#nickname-typing', {
                strings: ["多方通行8", "翰文侍林", "LinJohn8", "翰文侍林&多方通行8"],
                typeSpeed: 80,
                backSpeed: 50,
                loop: true,
                showCursor: true,
                cursorChar: '|',
                shuffle: true
            });
            
            // 2. 图片弹窗功能
            const lightbox = document.getElementById('lightbox');
            const lightboxImg = document.querySelector('.lightbox-img');
            const closeBtn = document.querySelector('.close');
            
            document.querySelectorAll('.gallery img').forEach(img => {
                img.addEventListener('click', () => {
                    lightbox.style.display = 'flex';
                    lightboxImg.src = img.src;
                    document.body.style.overflow = 'hidden';
                });
            });
            
            closeBtn.addEventListener('click', () => {
                lightbox.style.display = 'none';
                document.body.style.overflow = 'auto';
            });
            
            lightbox.addEventListener('click', (e) => {
                if (e.target === lightbox) {
                    lightbox.style.display = 'none';
                    document.body.style.overflow = 'auto';
                }
            });

            // 3. 返回顶部按钮
            const backToTopBtn = document.getElementById('backToTop');
            const contentPanel = document.querySelector('.content-panel');

            // 监听左侧内容区的滚动事件
            contentPanel.addEventListener('scroll', () => {
                if (contentPanel.scrollTop > 500) {
                    backToTopBtn.classList.add('show');
                } else {
                    backToTopBtn.classList.remove('show');
                }
            });

            backToTopBtn.addEventListener('click', () => {
                contentPanel.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });
        });

        // --- Three.js 核心变量和过渡逻辑 (右侧粒子特效) ---
        
        let attractorGroup;
        let renderer;
        let camera;
        let mouseX = 0;
        let mouseY = 0;
        let isMouseOverVisual = false;

        // 粒子和过渡相关的全局变量
        let positions; // 当前粒子位置数组 (Float32Array)
        let targetPositions; // 目标粒子位置数组 (Float32Array)
        const numPoints = 30000;
        let transitionAlpha = 1.0; // 过渡因子，0.0 到 1.0
        const transitionSpeed = 0.005; // 过渡速度，每帧增加 0.5%
        let geometry; // BufferGeometry 实例
        
        // 可用的 3D 几何体/吸引子生成函数
        const shapeGenerators = {
            // 洛伦兹吸引子（蝴蝶状）
            lorenz: () => {
                const pos = new Float32Array(numPoints * 3);
                let x = 0.1, y = 0, z = 0;
                const dt = 0.008, sigma = 10, rho = 28, beta = 8/3;
                for (let i = 0; i < numPoints; i++) {
                    const dx = sigma * (y - x) * dt;
                    const dy = (x * (rho - z) - y) * dt;
                    const dz = (x * y - beta * z) * dt;
                    x += dx; y += dy; z += dz;

                    // 缩小并调整位置
                    pos[i * 3] = x * 0.6; 
                    pos[i * 3 + 1] = y * 0.6;
                    pos[i * 3 + 2] = z * 0.6;
                }
                return pos;
            },
            
            // 球面螺旋线 (代表恒星/宇宙结构)
            sphereSpiral: () => {
                const pos = new Float32Array(numPoints * 3);
                const radius = 30;
                const spiralTurns = 100;
                for (let i = 0; i < numPoints; i++) {
                    const phi = (i / numPoints) * Math.PI; // 极角 (0 到 pi)
                    const theta = (i / numPoints) * Math.PI * 2 * spiralTurns; // 径向角

                    pos[i * 3] = radius * Math.sin(phi) * Math.cos(theta); // X
                    pos[i * 3 + 1] = radius * Math.cos(phi); // Y
                    pos[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta); // Z
                }
                return pos;
            },

            // 正弦曲线阵列 (代表波/频率/基因结构)
            sineWaveArray: () => {
                const pos = new Float32Array(numPoints * 3);
                const amplitude = 15;
                const frequency = 0.2;
                for (let i = 0; i < numPoints; i++) {
                    const t = (i / numPoints) * 100 - 50; // X范围 -50 到 50
                    const curveIndex = Math.floor(i / (numPoints / 10)); // 10条曲线

                    pos[i * 3] = t; // X
                    pos[i * 3 + 1] = amplitude * Math.sin(t * frequency + curveIndex * 0.5); // Y
                    pos[i * 3 + 2] = curveIndex * 4 - 20 + Math.random() * 2; // Z轴错开
                }
                return pos;
            },

            // 克里福德吸引子 (更复杂的混沌系统，类似于大脑神经元网络)
            clifford: () => {
                const pos = new Float32Array(numPoints * 3);
                let x = 0.1, y = 0, z = 0;
                const a = 1.7, b = 1.7, c = 0.6, d = 1.2;
                for (let i = 0; i < numPoints; i++) {
                    const nextX = Math.sin(a * y) + c * Math.cos(a * x);
                    const nextY = Math.sin(b * x) + d * Math.cos(b * y);
                    const nextZ = 0.5 * z + 0.1 * (x * x + y * y) * Math.sin(i * 0.01); 
                    
                    x = nextX; y = nextY; z = nextZ;

                    // 缩小并调整位置
                    pos[i * 3] = x * 15;
                    pos[i * 3 + 1] = y * 15;
                    pos[i * 3 + 2] = z * 10;
                }
                return pos;
            },

            // 环形结 (Torus Knot)
            torusKnot: () => {
              const pos = new Float32Array(numPoints * 3);
              const radius = 30; // 整体大小
              const p = 3, q = 4; // 决定结的类型

              for (let i = 0; i < numPoints; i++) {
                const t = (i / numPoints) * Math.PI * 2 * q; // 0 到 2*pi*q

                // 参数方程
                const r = Math.cos(q * t) + 2;
                const x = r * Math.cos(p * t);
                const y = r * Math.sin(p * t);
                const z = -Math.sin(q * t);

                pos[i * 3] = x * 5;
                pos[i * 3 + 1] = y * 5;
                pos[i * 3 + 2] = z * 5;
              }
              return pos;
            },

            // 双螺旋 (Double Helix / DNA 结构)
            doubleHelix: () => {
              const pos = new Float32Array(numPoints * 3);
              const radius = 15;
              const height = 40;
              const turns = 10;

              for (let i = 0; i < numPoints; i++) {
                const t = (i / numPoints) * Math.PI * 2 * turns; // 螺旋角度

                // Z 轴按顺序递增
                const z = (i / numPoints) * height - (height / 2);

                // 决定粒子是在主链 A 还是副链 B 上
                const chain = i % 2 === 0 ? 1 : -1;

                // Helix A:
                let xA = radius * Math.cos(t);
                let yA = radius * Math.sin(t);

                // Helix B (相位错开 180 度，即 PI)
                let xB = radius * Math.cos(t + Math.PI);
                let yB = radius * Math.sin(t + Math.PI);

                // 使用线性插值使粒子在 A 和 B 之间分布
                pos[i * 3] = (xA + xB) / 2 + Math.cos(t) * 3; // X (略微增加宽度)
                pos[i * 3 + 1] = (yA + yB) / 2 + Math.sin(t) * 3; // Y
                pos[i * 3 + 2] = z;                              // Z

                // 修正为双链结构：将粒子分配到两条螺旋线上
                if (chain === 1) { // 链 A
                  pos[i * 3] = radius * Math.cos(t);
                  pos[i * 3 + 1] = radius * Math.sin(t);
                } else { // 链 B
                  pos[i * 3] = radius * Math.cos(t + Math.PI);
                  pos[i * 3 + 1] = radius * Math.sin(t + Math.PI);
                }
              }
              return pos;
            },

            // 三维莫比乌斯环 (3D Möbius Strip)
            mobiusStrip: () => {
              const pos = new Float32Array(numPoints * 3);
              const radius = 25; // 环的半径
              const width = 10; // 带子的宽度

              for (let i = 0; i < numPoints; i++) {
                const u = (i / numPoints) * Math.PI * 2; // 绕环一圈 (0 到 2*pi)
                const v = (Math.random() - 0.5) * width; // 沿宽度分布 (-width/2 到 width/2)

                // 莫比乌斯环的关键在于这个扭曲因子 (u/2)
                const cos_u2 = Math.cos(u / 2);
                const sin_u2 = Math.sin(u / 2);

                const x = (radius + v * cos_u2) * Math.cos(u);
                const y = (radius + v * cos_u2) * Math.sin(u);
                const z = v * sin_u2;

                pos[i * 3] = x;
                pos[i * 3 + 1] = y;
                pos[i * 3 + 2] = z;
              }
              return pos;
            }
        };
        
        // 形状名称数组和当前索引（用于顺序切换）
        const shapeNames = Object.keys(shapeGenerators);
        let currentShapeIndex = 0; // 0: lorenz, 1: sphereSpiral, 2: sineWaveArray, 3: clifford

        // 顺序选择下一个吸引子并开始过渡
        function transitionToNewAttractor() {
            if (transitionAlpha < 1.0 && transitionAlpha > 0) return; // 仍在过渡中，不打断

            // 计算下一个形状的索引 (循环：0 -> 1 -> 2 -> 3 -> 0)
            currentShapeIndex = (currentShapeIndex + 1) % shapeNames.length;
            const nextShapeName = shapeNames[currentShapeIndex];

            // 设置新的目标位置
            targetPositions = shapeGenerators[nextShapeName]();
            // 重置过渡因子，准备开始动画
            transitionAlpha = 0.0;
            
            // 目标位置准备好后，更新颜色
            const colors = new Float32Array(numPoints * 3);
            // 生成随机的霓虹颜色
            const randomColor = () => Math.max(0.3, Math.random()); // 确保不是太暗
            const color1 = new THREE.Color(randomColor(), randomColor(), randomColor()); 
            const color2 = new THREE.Color(randomColor(), randomColor(), randomColor());

            for (let i = 0; i < numPoints; i++) {
                const c = color1.clone().lerp(color2, i / numPoints);
                colors[i * 3] = c.r;
                colors[i * 3 + 1] = c.g;
                colors[i * 3 + 2] = c.b;
            }
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.attributes.color.needsUpdate = true;
        }

        // 监听 Three.js 库加载
        window.addEventListener('load', () => {
            // 确保 Three.js 已加载
            if (typeof THREE !== 'undefined') {
                initThreeScene();
                // 每 15 秒触发一次形状过渡
                setInterval(transitionToNewAttractor, 15000); 
            } else {
                // 延迟重试以防加载失败
                console.error("THREE.js library not loaded. Retrying...");
                setTimeout(initThreeScene, 500); 
            }
        });

        // Three.js 场景初始化函数
        function initThreeScene() {
            const container = document.getElementById('three-background');
            const visualLoader = document.getElementById('visual-loader');
            
            // 基础设置
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050510, 0.0025);

            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 75; 

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            
            // 初始化粒子位置（使用初始的洛伦兹吸引子）
            positions = shapeGenerators.lorenz();
            targetPositions = positions.slice(); // 初始目标位置与当前位置相同

            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            // 颜色初始化
            const colors = new Float32Array(numPoints * 3);
            const color1 = new THREE.Color(0x00f3ff); 
            const color2 = new THREE.Color(0xbc13fe);
            for (let i = 0; i < numPoints; i++) {
                const c = color1.clone().lerp(color2, i / numPoints);
                colors[i * 3] = c.r;
                colors[i * 3 + 1] = c.g;
                colors[i * 3 + 2] = c.b;
            }
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            const points = new THREE.Points(geometry, material);
            attractorGroup = new THREE.Group();
            attractorGroup.add(points);
            scene.add(attractorGroup);
            
            // 星空背景 
            const starGeo = new THREE.BufferGeometry();
            const starCount = 1000;
            const starPos = new Float32Array(starCount * 3);
            for(let i=0; i<starCount*3; i++) { starPos[i] = (Math.random() - 0.5) * 200; }
            starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({ color: 0x888888, size: 0.1, transparent: true });
            const starMesh = new THREE.Points(starGeo, starMat);
            scene.add(starMesh);


            // 初始化完成后，移除 3D 加载条
            visualLoader.style.opacity = 0;
            setTimeout(() => { visualLoader.style.display = 'none'; }, 600);

            // 鼠标交互监听器
            const visualPanel = document.getElementById('visual-panel');

            visualPanel.addEventListener('mouseenter', () => { isMouseOverVisual = true; visualPanel.style.cursor = 'grabbing'; });
            visualPanel.addEventListener('mouseleave', () => { isMouseOverVisual = false; visualPanel.style.cursor = 'grab'; });
            
            visualPanel.addEventListener('mousemove', (e) => {
                // 归一化鼠标位置 (仅在右侧面板内计算)
                const rect = visualPanel.getBoundingClientRect();
                // 调整系数，使鼠标移动效果不那么剧烈
                mouseX = (e.clientX - rect.left - rect.width / 2) * 0.00005;
                mouseY = (e.clientY - rect.top - rect.height / 2) * 0.00005;
            });
            
            // 渲染循环
            const animate = () => {
                requestAnimationFrame(animate);

                // 粒子形状过渡逻辑 (Linear Interpolation)
                if (transitionAlpha < 1.0) {
                    transitionAlpha = Math.min(1.0, transitionAlpha + transitionSpeed);
                    const currentPositions = geometry.attributes.position.array;
                    const progress = transitionAlpha;

                    for (let i = 0; i < numPoints * 3; i++) {
                        // 线性插值：(旧位置 * (1 - 进度)) + (新位置 * 进度)
                        currentPositions[i] = positions[i] * (1 - progress) + targetPositions[i] * progress;
                    }

                    geometry.attributes.position.needsUpdate = true;
                    // 当过渡完成，将当前位置更新为目标位置，为下一次过渡做准备
                    if (transitionAlpha >= 1.0) {
                        positions = targetPositions.slice();
                    }
                }


                // 自转始终进行
                attractorGroup.rotation.z += 0.002;
                starMesh.rotation.y += 0.0005;
                starMesh.rotation.x += 0.0003;


                if (isMouseOverVisual) {
                    // 仅当鼠标悬停在右侧时，才响应交互（平滑过渡）
                    attractorGroup.rotation.y += 0.2 * (mouseX * 10 - attractorGroup.rotation.y);
                    attractorGroup.rotation.x += 0.2 * (mouseY * 10 - attractorGroup.rotation.x);
                } else {
                    // 鼠标移出后，逐渐回到水平
                    attractorGroup.rotation.y += 0.02 * (0 - attractorGroup.rotation.y);
                    attractorGroup.rotation.x += 0.02 * (0 - attractorGroup.rotation.x);
                }

                renderer.render(scene, camera);
            };
            animate();

            // 窗口调整
            window.addEventListener('resize', () => {
                const w = container.clientWidth;
                const h = container.clientHeight;
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
            });
        }
    </script>
</body>
</html>